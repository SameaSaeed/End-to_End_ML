# -*- coding: utf-8 -*-
"""dask_inference.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11WNQ4nX7mgQBHuyZvcVvC5yum9ByC2SU
"""

!pip install dask --quiet

!pip install scikit-learn xgboost mlflow joblib pyyaml --quiet

import joblib
import dask.dataframe as dd
import numpy as np
from datetime import datetime
# from data.schemas import HousePredictionRequest, PredictionResponse

# Load model and preprocessor
MODEL_PATH = "/content/models/trained_model.pkl"
PREPROCESSOR_PATH = "/content/preprocessor.pkl"

model = joblib.load(MODEL_PATH)
preprocessor = joblib.load(PREPROCESSOR_PATH)

def prepare_features(df: dd.DataFrame) -> dd.DataFrame:
    """Add engineered features for prediction (lazy)."""
    df['house_age'] = datetime.now().year - df['year_built']
    df['bed_bath_ratio'] = df['bedrooms'] / df['bathrooms']
    df['price_per_sqft'] = 0  # dummy
    df['bed_bath_ratio'] = df['bed_bath_ratio'].replace([np.inf, -np.inf], 0)
    return df

def predict(requests):
    """
    Unified prediction function.
    Accepts a single HousePredictionRequest or a list of them.
    Returns a list of PredictionResponse objects.
    """
    # Ensure we have a list
    if not isinstance(requests, list):
        requests = [requests]

    # Convert requests to pandas DataFrame, then to Dask DataFrame
    df = dd.from_pandas(
        pd.DataFrame([req.dict() for req in requests]),
        npartitions=1
    )
    df = prepare_features(df).compute()  # compute partitions for scikit-learn

    # Preprocess and predict
    X_processed = preprocessor.transform(df)
    preds = model.predict(X_processed)

    results = []
    for idx, predicted_price in enumerate(preds):
        predicted_price = round(float(predicted_price), 2)
        ci = [round(predicted_price * 0.9, 2), round(predicted_price * 1.1, 2)]

        # Feature importance
        feature_importance = {}
        if hasattr(model, "feature_importances_"):
            feature_importance = dict(zip(df.columns, model.feature_importances_))

        results.append(PredictionResponse(
            predicted_price=predicted_price,
            confidence_interval=ci,
            features_importance=feature_importance,
            prediction_time=datetime.now().isoformat()
        ))
    return results